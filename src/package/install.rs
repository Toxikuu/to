// package/install.rs

use std::{
    collections::HashSet,
    fs,
    path::Path,
};

use fshelpers::mkdir_p;
use once_cell::sync::Lazy;
use permitit::Permit;
use thiserror::Error;
use tracing::{
    debug,
    error,
    info,
    instrument,
    warn,
};

use super::{
    FormError,
    Package,
};
use crate::{
    exec,
    package::message::MessageHook,
};

/// # Check whether we're in the build chroot
///
/// This checks whether `to` is being run from the build chroot by checking for the existence and
/// types of /D and /pkg. This function is memoized.
pub fn in_build_environment() -> bool {
    static IN_BUILD_ENV: Lazy<bool> = Lazy::new(|| Path::new("/D").is_dir() && Path::new("/pkg").is_file());
    *IN_BUILD_ENV
}

#[derive(Debug, Error)]
pub enum InstallError {
    #[error("Package is already installed")]
    AlreadyInstalled,

    #[error("Package is missing a distfile")]
    MissingDistfile,

    #[error("Failed to form package")]
    FormError(#[from] FormError),

    #[error("Failed to install dependencies")]
    Dependencies(Box<InstallError>),

    #[error("Failed to execute install command")]
    Execution,

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
}

impl Package {
    /// Core logic of `install()`, split into a separate function to take the visited hashmap
    /// generated by the upper `install()`. This is used to avoid pesky infinite recursion.
    pub fn install_inner(
        &self,
        force: bool,
        full_force: bool,
        visited: &mut HashSet<String>, // cheaper to clone than `Package`
        suppress: bool,
        root: Option<&str>, // the root to which packages are installed, defaulting to /
    ) -> Result<(), InstallError> {
        // Make `full_force` imply `force`
        let force = full_force || force;

        if !visited.insert(self.name.to_owned()) {
            // Avoid aforementioned pesky infinite recursion
            return Ok(());
        }

        let version = &self.version;
        let dist = self.distfile();
        let dist_str = dist.display();

        let installed_version = self.installed_version();
        let updating = installed_version
            .as_ref()
            .is_some_and(|v| *v != self.version);

        // Issue a warning that the latest version of a package is already installed if the package
        // is up-to-date, installed, and --force is not passed.
        if !updating && self.is_installed() && !force {
            debug!("Already installed {self:-}");
            return Err(InstallError::AlreadyInstalled)
        }

        if !dist.exists() {
            error!("Missing distfile for {self:-}");
            return Err(InstallError::MissingDistfile)
        }

        // Only install required dependencies
        let deps = self.collect_install_deps();
        for dep in deps {
            dep.install_inner(full_force, full_force, visited, suppress, root)
                .permit(|e| matches!(e, InstallError::AlreadyInstalled))
                .map_err(|e| InstallError::Dependencies(Box::new(e)))?
        }

        let data = &self.datadir();
        let iv = data.join("IV");
        let manifest = data.join(format!("MANIFEST@{}", version.srversion()));
        let pkgfile = &self.pkgfile();

        mkdir_p(data)?;
        exec!(
            r#"

        set -euo pipefail
        tource {pkgfile:?}

        if [ "{root}" = "/" ]; then
            if is_function prei; then
                prei
            fi
        fi

        mkdir -p "{root}"
        tar xf '{dist_str}' -C "{root}" \
            --keep-directory-symlink    \
            --numeric-owner             \
            --no-overwrite-dir
        mv -f /MANIFEST {manifest:?}

        if [ "{root}" = "/" ]; then
            if is_function posti; then
                posti
            elif is_function i; then
                i
            fi
        fi

        "#,
        root = root.unwrap_or("/")
        )
        .map_err(|_| InstallError::Execution)?;

        // Do some other stuff if updating
        if updating {
            // TODO: Consider adding update hooks (but wait until needed)
            if let Err(e) = self.remove_dead_files_after_update() {
                warn!("Failed to remove dead files for {self:-}: {e}")
            } else {
                info!(
                    "Removed dead files for {}@{}",
                    self.name,
                    installed_version.unwrap().srversion()
                )
            }

            self.message(suppress, MessageHook::Update);
        } else {
            self.message(suppress, MessageHook::Install);
        }

        // We write the version after removing dead files
        fs::write(iv, version.rversion())?;
        info!("Installed {self:-}");
        Ok(())
    }

    /// # Install a package, ignoring the case where it's already installed
    ///
    /// Wraps `install_inner()`
    ///
    /// # Arguments
    /// * `force`       - Whether the package should be forcibly (re)installed
    /// * `full_force`  - Whether all dependencies should be forcible (re)installed
    /// * `suppress`    - Whether to suppress messages
    /// * `root`        - The directory to which the package should be installed (defaults to /)
    ///
    /// # Errors
    // TODO: ^
    #[instrument(skip(self, force))]
    pub fn install(
        &self,
        force: bool,
        full_force: bool,
        suppress: bool,
        root: Option<&str>,
    ) -> Result<(), InstallError> {
        let mut visited = HashSet::new();
        self.install_inner(force, full_force, &mut visited, suppress, root)
            .permit(|e| matches!(e, InstallError::AlreadyInstalled))
    }

    /// # Installs a package without its dependencies, ignoring the case where it's already
    /// installed
    ///
    /// Wraps `install_inner()`
    ///
    /// # Arguments
    /// * `force`       - Whether the package should be forcibly (re)installed
    /// * `suppress`    - Whether to suppress messages
    /// * `root`        - The directory to which the package should be installed (defaults to /)
    ///
    /// # Errors
    // TODO: ^
    pub fn install_no_deps(
        &self,
        force: bool,
        suppress: bool,
        root: Option<&str>,
    ) -> Result<(), InstallError> {
        let mut pkg = self.clone();
        pkg.dependencies = vec![];

        let mut visited = HashSet::new();
        pkg.install_inner(force, false, &mut visited, suppress, root)
            .permit(|e| matches!(e, InstallError::AlreadyInstalled))
    }
}
