// package/install.rs

use std::{
    collections::HashSet,
    path::Path,
};

use once_cell::sync::Lazy;
use permitit::Permit;
use thiserror::Error;
use tracing::{
    debug,
    error,
    info,
    instrument,
    warn,
};

use super::{
    FormError,
    Package,
};
use crate::{
    exec,
    package::message::MessageHook,
};

/// # Check whether we're in the build chroot
///
/// This checks whether `to` is being run from the build chroot by checking for the existence of
/// /D. This function is memoized.
pub fn in_build_environment() -> bool {
    static IN_BUILD_ENV: Lazy<bool> = Lazy::new(|| Path::new("/D").exists());
    *IN_BUILD_ENV
}

#[derive(Debug, Error)]
pub enum InstallError {
    #[error("Package is already installed")]
    AlreadyInstalled,

    #[error("Package is missing a distfile")]
    MissingDistfile,

    #[error("Failed to form package")]
    FormError(#[from] FormError),

    #[error("Failed to install dependencies")]
    Dependencies(Box<InstallError>),

    #[error("Failed to execute install command")]
    Execution,
}

impl Package {
    /// Core logic of `install()`, split into a separate function to take the visited hashmap
    /// generated by the upper `install()`. This is used to avoid pesky infinite recursion.
    pub fn install_inner(
        &self,
        force: bool,
        full_force: bool,
        visited: &mut HashSet<String>,
        suppress: bool,
    ) -> Result<(), InstallError> {
        if !visited.insert(self.to_string()) {
            // Avoid pesky infinite recursion
            return Ok(());
        }

        let version = &self.version;
        let dist = self.distfile();
        let dist_str = dist.display();

        let installed_version = self.installed_version();
        let updating = installed_version
            .as_ref()
            .is_some_and(|v| *v != self.version);

        // Issue a warning that the latest version of a package is already installed if the package
        // is up-to-date, installed, and --force is not passed.
        if !updating && self.is_installed() && !force {
            debug!("Already installed {self:-}");
            return Err(InstallError::AlreadyInstalled)
        }

        if !dist.exists() {
            error!("Missing distfile for {self:-}");
            return Err(InstallError::MissingDistfile)
        }

        // Only install runtime dependencies if we aren't in the build environment
        let in_chroot = in_build_environment();
        self.install_deps(full_force, !in_chroot, visited, in_chroot)
            .permit(|e| matches!(e, InstallError::AlreadyInstalled))
            .map_err(|e| InstallError::Dependencies(Box::new(e)))?;

        let data = &self.datadir();
        let iv = data.join("IV");
        let manifest = data.join(format!("MANIFEST@{version}"));
        let pkgfile = &self.pkgfile();

        exec!(
            r#"

        source {pkgfile:?}
        mkdir -pv {data:?}

        if is_function prei; then
            prei
        fi

        touch /etc/to/exclude
        tar xvf '{dist_str}' -C /           \
            --keep-directory-symlink        \
            --numeric-owner                 \
            --no-overwrite-dir              \
            --exclude=MANIFEST              \
            --exclude-from=/etc/to/exclude  |
        sed -e '/^.\/$/d'   \
            -e '/^$/d'      \
            -e 's,/$,,'     |
        tee > {manifest:?}

        echo '{version}' > {iv:?}

        if is_function posti; then
            posti
        elif is_function i; then
            i
        fi

        "#
        )
        .map_err(|_| InstallError::Execution)?;

        info!("Installed {self:-}");

        // Do some other stuff if updating
        if updating {
            // TODO: Consider adding update hooks (but wait until needed)
            if let Err(e) = self.remove_dead_files_after_update() {
                warn!("Failed to remove dead files for {self:-}: {e}")
            } else {
                info!(
                    "Removed dead files for {}@{}",
                    self.name,
                    installed_version.unwrap()
                )
            }

            self.message(suppress, MessageHook::Update);
        } else {
            self.message(suppress, MessageHook::Install);
        }

        Ok(())
    }

    /// Install a package
    /// Calls `install_deps()` under the hood
    #[instrument(skip(self, force))]
    pub fn install(
        &self,
        force: bool,
        full_force: bool,
        suppress: bool,
    ) -> Result<(), InstallError> {
        let mut visited = HashSet::new();
        self.install_inner(force, full_force, &mut visited, suppress)
    }
}
