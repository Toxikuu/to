// package/install.rs

use std::collections::HashSet;

use anyhow::{
    Context,
    Result,
    bail,
};
use permitit::Permit;
use tracing::{
    error,
    info,
    instrument,
    warn,
};

use super::Package;
use crate::{
    exec,
    package::message::MessageHook,
};

impl Package {
    /// Core logic of `install()`, split into a separate function to take the visited hashmap
    /// generated by the upper `install()`. This is used to avoid pesky infinite recursion.
    pub fn install_inner(&self, force: bool, visited: &mut HashSet<String>) -> Result<()> {
        if !visited.insert(self.to_string()) {
            // Avoid pesky infinite recursion
            return Ok(());
        }

        let version = &self.version;
        let dist = self.distfile();
        let dist_str = dist.display();

        let installed_version = self.installed_version();
        let updating = installed_version
            .as_ref()
            .is_some_and(|v| *v != self.version);

        // Issue a warning that the latest version of a package is already installed if the package
        // is up-to-date, installed, and --force is not passed.
        if !updating && self.is_installed() && !force {
            warn!("Already installed {self}");
            bail!("Already installed")
        }

        if !dist.exists() {
            error!("Missing distfile for {self}");
            bail!("Missing distfile");
        }

        self.install_deps(force, visited)
            .permit(|e| e.to_string() == "Already installed")
            .with_context(|| format!("Failed to install dependencies for {self}"))?;

        let data = &self.datadir();
        let iv = data.join("IV");
        let manifest = data.join(format!("MANIFEST@{version}"));
        let pkgfile = &self.pkgfile();

        exec!(
            r#"

        source {pkgfile:?}
        mkdir -pv {data:?}
        
        if is_function prei; then
            prei
        fi

        tar xvf '{dist_str}' -C /           \
            --keep-directory-symlink        \
            --numeric-owner                 \
            --no-overwrite-dir              \
            --exclude=MANIFEST              \
            --exclude-from=/etc/to/exclude  |
        sed -e '/^.\/$/d'   \
            -e '/^$/d'      \
            -e 's,/$,,'     |
        tee > {manifest:?}

        echo '{version}' > {iv:?}

        if is_function posti; then
            posti
        fi

        "#
        )
        .with_context(|| format!("Failed to install {self}"))?;

        info!("Installed {self}");

        // Do some other stuff if updating
        if updating {
            // TODO: Consider adding update hooks (but wait until needed)
            if let Err(e) = self.remove_dead_files_after_update() {
                warn!("Failed to remove dead files for {self}: {e}")
            }
            info!(
                "Removed dead files for {}@{}",
                self.name,
                installed_version.unwrap()
            );
            self.message(MessageHook::Update);
        } else {
            self.message(MessageHook::Install);
        }

        Ok(())
    }

    /// Install a package
    /// Calls `install_deps()` under the hood
    #[instrument]
    pub fn install(&self, force: bool) -> Result<()> {
        let mut visited = HashSet::new();
        self.install_inner(force, &mut visited)
    }
}
