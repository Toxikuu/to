// package/install.rs

use std::{
    collections::HashSet,
    path::Path,
};

use anyhow::{
    Context,
    Result,
    bail,
};
use once_cell::sync::Lazy;
use permitit::Permit;
use tracing::{
    debug,
    error,
    info,
    instrument,
    warn,
};

use super::Package;
use crate::{
    exec,
    package::message::MessageHook,
};

/// # Check whether we're in the build chroot
///
/// This checks whether `to` is being run from the build chroot by checking for the existence of
/// /D. This function is memoized.
pub fn in_build_environment() -> bool {
    static IN_BUILD_ENV: Lazy<bool> = Lazy::new(|| Path::new("/D").exists());
    *IN_BUILD_ENV
}

impl Package {
    /// Core logic of `install()`, split into a separate function to take the visited hashmap
    /// generated by the upper `install()`. This is used to avoid pesky infinite recursion.
    pub fn install_inner(&self, force: bool, visited: &mut HashSet<String>) -> Result<()> {
        if !visited.insert(self.to_string()) {
            // Avoid pesky infinite recursion
            return Ok(());
        }

        let version = &self.version;
        let dist = self.distfile();
        let dist_str = dist.display();

        let installed_version = self.installed_version();
        let updating = installed_version
            .as_ref()
            .is_some_and(|v| *v != self.version);

        // Issue a warning that the latest version of a package is already installed if the package
        // is up-to-date, installed, and --force is not passed.
        if !updating && self.is_installed() && !force {
            debug!("Already installed {self:-}");
            bail!("Already installed")
        }

        if !dist.exists() {
            error!("Missing distfile for {self:-}");
            bail!("Missing distfile");
        }

        // Only install runtime dependencies if we aren't in the build environment
        self.install_deps(force, !in_build_environment(), visited)
            .permit(|e| e.to_string() == "Already installed")
            .with_context(|| format!("Failed to install dependencies for {self:-}"))?;

        let data = &self.datadir();
        let iv = data.join("IV");
        let manifest = data.join(format!("MANIFEST@{version}"));
        let pkgfile = &self.pkgfile();

        exec!(
            r#"

        source {pkgfile:?}
        mkdir -pv {data:?}
        
        if is_function prei; then
            prei
        fi

        touch /etc/to/exclude
        tar xvf '{dist_str}' -C /           \
            --keep-directory-symlink        \
            --numeric-owner                 \
            --no-overwrite-dir              \
            --exclude=MANIFEST              \
            --exclude-from=/etc/to/exclude  |
        sed -e '/^.\/$/d'   \
            -e '/^$/d'      \
            -e 's,/$,,'     |
        tee > {manifest:?}

        echo '{version}' > {iv:?}

        if is_function posti; then
            posti
        elif is_function i; then
            i
        fi

        "#
        )
        .with_context(|| format!("Failed to install {self:-}"))?;

        info!("Installed {self:-}");

        // Do some other stuff if updating
        if updating {
            // TODO: Consider adding update hooks (but wait until needed)
            if let Err(e) = self.remove_dead_files_after_update() {
                warn!("Failed to remove dead files for {self:-}: {e}")
            } else {
                info!(
                    "Removed dead files for {}@{}",
                    self.name,
                    installed_version.unwrap()
                )
            }

            self.message(MessageHook::Update);
        } else {
            self.message(MessageHook::Install);
        }

        Ok(())
    }

    /// Install a package
    /// Calls `install_deps()` under the hood
    #[instrument(skip(self, force))]
    pub fn install(&self, force: bool) -> Result<()> {
        let mut visited = HashSet::new();
        self.install_inner(force, &mut visited)
    }
}
